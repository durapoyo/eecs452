#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BNO055.h>
#include <utility/imumaths.h>
#include <Audio.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>
#include "AudioFilterEqualizer_I16.h"

// ----------------- AUDIO SYSTEM -----------------
AudioPlaySdWav      playDeckA;   // original song or deck A
AudioPlaySdWav      playDeckB;   // deck B for mixer mode
AudioEffectGranular granularLeft;
AudioEffectGranular granularRight;
AudioFilterEqualizer eq1;
AudioMixer4 mixer;                // for mixer mode
AudioOutputI2S       i2s1;

AudioConnection patch1(playDeckA, 0, granularLeft, 0);
AudioConnection patch2(playDeckA, 1, granularRight, 0);
AudioConnection patch3(granularLeft, 0, i2s1, 0);
AudioConnection patch4(granularRight, 0, i2s1, 1);
AudioConnection patch5(playDeckA, 0, eq1, 0);
AudioConnection patch6(eq1, 0, i2s1, 0);
AudioConnection patch7(playDeckA, 1, i2s1, 1);

// Mixer connections
AudioConnection patch8(playDeckA, 0, mixer, 0);
AudioConnection patch9(playDeckB, 0, mixer, 1);
AudioConnection patch10(mixer, 0, i2s1, 0);
AudioConnection patch11(mixer, 0, i2s1, 1);

AudioControlSGTL5000 sgtl5000;

// ----------------- IMU -----------------
Adafruit_BNO055 bno = Adafruit_BNO055(55, 0x28, &Wire2);
bool imuConnected = false;

// ----------------- FILTERS -----------------
const float ALPHA_ACCEL = 0.22f;
const float ALPHA_GYRO  = 0.16f;
struct Vec3 { float x; float y; float z; };
Vec3 accelFilt = {0,0,0};
Vec3 gyroFilt  = {0,0,0};

// ----------------- TIMING / COOLDOWN -----------------
const unsigned long IMU_POLL_MS = 12;
const unsigned long GESTURE_COOLDOWN_MS = 500; 
unsigned long lastConfirmedGesture = 0;

// ----------------- GLOBAL VARIABLES -----------------
bool isPlaying = false;
bool eqMode = false;
bool tempoMode = false;
bool mixerMode = false;

float volumeLevel = 0.3;
float pitchShift  = 1.0;      
float playbackRate = 1.0;     

const char *songs[] = {"song1.wav", "song2.wav", "song3.wav", "song4.wav"};
int currentSong = 0;
int currentSongB = 0; // for mixer deck

#define GRAIN_MEMORY 12800
int16_t granularMemoryL[GRAIN_MEMORY];
int16_t granularMemoryR[GRAIN_MEMORY];

// ----------------- IIR FILTER -----------------
inline float iirf(float prev, float sample, float alpha) {
  return alpha * sample + (1.0f - alpha) * prev;
}
inline void updateFilters(const sensors_event_t &lin, const sensors_event_t &gyr) {
  accelFilt.x = iirf(accelFilt.x, lin.acceleration.x, ALPHA_ACCEL);
  accelFilt.y = iirf(accelFilt.y, lin.acceleration.y, ALPHA_ACCEL);
  accelFilt.z = iirf(accelFilt.z, lin.acceleration.z, ALPHA_ACCEL);

  gyroFilt.x  = iirf(gyroFilt.x,  gyr.gyro.x, ALPHA_GYRO);
  gyroFilt.y  = iirf(gyroFilt.y,  gyr.gyro.y, ALPHA_GYRO);
  gyroFilt.z  = iirf(gyroFilt.z,  gyr.gyro.z, ALPHA_GYRO);
}

// ----------------- DEBOUNCE -----------------
bool readyForGesture() { return (millis() - lastConfirmedGesture) >= GESTURE_COOLDOWN_MS; }
void confirmGesture() { lastConfirmedGesture = millis(); }

// ----------------- SONG HELPERS -----------------
void playCurrentSongA() {
  playDeckA.play(songs[currentSong]);
  granularLeft.begin(granularMemoryL, GRAIN_MEMORY);
  granularRight.begin(granularMemoryR, GRAIN_MEMORY);
  granularLeft.beginPitchShift(20);
  granularRight.beginPitchShift(20);
  granularLeft.setSpeed(1.0f);
  granularRight.setSpeed(1.0f);
  sgtl5000.volume(volumeLevel);
  isPlaying = true;
  Serial.printf("Deck A playing: %s\n", songs[currentSong]);
}

void playNextDeckB() {
  currentSongB = (currentSong + 1) % (sizeof(songs)/sizeof(songs[0]));
  playDeckB.play(songs[currentSongB]);
  Serial.printf("Deck B playing: %s\n", songs[currentSongB]);
}

// ----------------- EQ -----------------
#define EQ_TAPS 200
float32_t fBand[] = {200.0, 1200.0, 4000.0, 22050.0};
float32_t dbBand[] = {0.0,0.0,0.0,0.0};
float32_t scaleCoeff = 16384.0f;
int16_t eqCoeffs[EQ_TAPS];
float prevDbBand[3] = {0,0,0};

void buildEQ() {
  uint16_t err = eq1.equalizerNew(4, fBand, dbBand, EQ_TAPS, eqCoeffs, 60.0f, scaleCoeff);
  if (err) Serial.printf("EQ build error code %d\n", err);
}

// ----------------- NORMAL MODE -----------------
void handleGyroControls() {
  if (!readyForGesture()) return;

  // Volume
  float rollRate = gyroFilt.x;
  const float VOL_THRESH = 6.0;
  if (rollRate > VOL_THRESH) { volumeLevel = min(1.0f, volumeLevel+0.05f); sgtl5000.volume(volumeLevel); Serial.printf("Volume++ → %.2f\n", volumeLevel); confirmGesture(); }
  else if (rollRate < -VOL_THRESH) { volumeLevel = max(0.0f, volumeLevel-0.05f); sgtl5000.volume(volumeLevel); Serial.printf("Volume-- → %.2f\n", volumeLevel); confirmGesture(); }

  // Pitch
  float pitchRate = gyroFilt.y;
  const float PITCH_THRESH = 6.0;
  if (pitchRate > PITCH_THRESH) { pitchShift +=0.05f; if(pitchShift>2.5f) pitchShift=2.5f; granularLeft.setSpeed(pitchShift); granularRight.setSpeed(pitchShift); Serial.printf("Pitch UP → %.2f\n", pitchShift); confirmGesture(); }
  else if (pitchRate < -PITCH_THRESH) { pitchShift -=0.05f; if(pitchShift<0.3f)pitchShift=0.3f; granularLeft.setSpeed(pitchShift); granularRight.setSpeed(pitchShift); Serial.printf("Pitch DOWN → %.2f\n", pitchShift); confirmGesture(); }
}

// ----------------- TEMPO MODE -----------------
void handleTempoControls() {
  if (!readyForGesture()) return;
  float rollRate = gyroFilt.x;
  const float TEMPO_THRESH = 6.0;
  if (rollRate > TEMPO_THRESH) { playbackRate += 0.05f; if(playbackRate>2.0f) playbackRate=2.0f; granularLeft.setSpeed(playbackRate); granularRight.setSpeed(playbackRate); Serial.printf("Tempo UP → %.2fx\n", playbackRate); confirmGesture(); }
  else if (rollRate < -TEMPO_THRESH) { playbackRate -= 0.05f; if(playbackRate<0.5f) playbackRate=0.5f; granularLeft.setSpeed(playbackRate); granularRight.setSpeed(playbackRate); Serial.printf("Tempo DOWN → %.2fx\n", playbackRate); confirmGesture(); }
}

// ----------------- EQ MODE -----------------
void handleEQControls() {
  if (!readyForGesture()) return;
  const float GYRO_THRESH = 6.0f;
  const float ACCEL_THRESH = 1.0f;

  if(gyroFilt.x > GYRO_THRESH) dbBand[0]+=1.0f; else if(gyroFilt.x < -GYRO_THRESH) dbBand[0]-=1.0f;
  if(gyroFilt.y > GYRO_THRESH) dbBand[1]+=1.0f; else if(gyroFilt.y < -GYRO_THRESH) dbBand[1]-=1.0f;
  if(accelFilt.y > ACCEL_THRESH) dbBand[2]+=1.0f; else if(accelFilt.y < -ACCEL_THRESH) dbBand[2]-=1.0f;

  for(int i=0;i<3;i++){ if(dbBand[i]>12.0f) dbBand[i]=12.0f; if(dbBand[i]<-12.0f) dbBand[i]=-12.0f; }
  buildEQ();
  if(dbBand[0]!=prevDbBand[0] || dbBand[1]!=prevDbBand[1] || dbBand[2]!=prevDbBand[2]){ Serial.printf("EQ → Bass: %.1f, Mid: %.1f, Treble: %.1f\n", dbBand[0], dbBand[1], dbBand[2]); for(int i=0;i<3;i++) prevDbBand[i]=dbBand[i]; }
  confirmGesture();
}

// ----------------- MIXER MODE -----------------
void handleMixerCrossfade() {
  if (!readyForGesture() || !mixerMode) return;
  float y = accelFilt.y;
  const float THRESH = 6.0;
  if (y > THRESH) { mixer.gain(0,0.3); mixer.gain(1,0.8); Serial.println("Mixer → Deck B louder"); confirmGesture(); }
  else if (y < -THRESH) { mixer.gain(0,0.8); mixer.gain(1,0.3); Serial.println("Mixer → Deck A louder"); confirmGesture(); }
}

// ----------------- SETUP -----------------
void setup() {
  Serial.begin(115200);
  delay(80);
  Wire2.setClock(400000);

  imuConnected = bno.begin();
  if(imuConnected){ bno.setExtCrystalUse(true); Serial.println("BNO055 IMU detected."); }
  else Serial.println("No BNO055 detected.");

  AudioMemory(40);
  sgtl5000.enable();
  sgtl5000.volume(volumeLevel);

  granularLeft.begin(granularMemoryL, GRAIN_MEMORY);
  granularRight.begin(granularMemoryR, GRAIN_MEMORY);

  if(!SD.begin(BUILTIN_SDCARD)){ Serial.println("SD init FAILED!"); while(1); }

  buildEQ();
}

// ----------------- MAIN LOOP -----------------
void loop() {
  unsigned long now = millis();

  // --- Serial gestures ---
  if(Serial.available()){
    int gesture = Serial.read();
    switch(gesture){
      case 1: if(!isPlaying){ playCurrentSongA(); eqMode=false; tempoMode=false; mixerMode=false; } break;
      case 2: if(isPlaying){ playDeckA.stop(); isPlaying=false; } break;
      case 3: eqMode=true; tempoMode=false; mixerMode=false; Serial.println("EQ mode activated"); break;
      case 4: if(isPlaying){ currentSong = (currentSong+1)%4; playCurrentSongA(); Serial.println("Next song"); } break;
      case 6: tempoMode=true; eqMode=false; mixerMode=false; Serial.println("Tempo mode activated"); break;
      case 5: // thumbs up → mixer mode
        if(!mixerMode){
          mixerMode=true; eqMode=false; tempoMode=false; Serial.println("Mixer mode ON");
          if(isPlaying) playNextDeckB();
          mixer.gain(0,0.5); mixer.gain(1,0.5);
        } else {
          mixerMode=false;
          Serial.println("Mixer mode OFF");
          playDeckB.stop();
        }
        break;
    }
  }

  // --- IMU polling ---
  if(imuConnected && isPlaying && (now - lastConfirmedGesture > IMU_POLL_MS)){
    sensors_event_t lin, gyr;
    bno.getEvent(&lin, Adafruit_BNO055::VECTOR_LINEARACCEL);
    bno.getEvent(&gyr, Adafruit_BNO055::VECTOR_GYROSCOPE);
    updateFilters(lin, gyr);

    if(mixerMode) handleMixerCrossfade();
    else if(eqMode) handleEQControls();
    else if(tempoMode) handleTempoControls();
    else handleGyroControls();
  }
}





